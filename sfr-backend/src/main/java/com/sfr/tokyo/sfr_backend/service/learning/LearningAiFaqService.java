package com.sfr.tokyo.sfr_backend.service.learning;

import com.sfr.tokyo.sfr_backend.dto.learning.LearningAiFaqDto;
import com.sfr.tokyo.sfr_backend.entity.learning.LearningAiFaq;
import com.sfr.tokyo.sfr_backend.repository.learning.LearningAiFaqRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * 学習AI FAQ サービス
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class LearningAiFaqService {

    private final LearningAiFaqRepository faqRepository;

    // ========== 基本CRUD操作 ==========

    /**
     * FAQ作成
     */
    @Transactional
    public LearningAiFaqDto createFaq(LearningAiFaqDto faqDto) {
        log.info("FAQ作成開始: question={}", faqDto.getQuestion());

        LearningAiFaq faq = new LearningAiFaq();
        BeanUtils.copyProperties(faqDto, faq, "id", "createdAt", "updatedAt");

        // 初期値設定
        faq.setStatus(LearningAiFaq.FaqStatus.DRAFT);
        faq.setIsAutoGenerated(false);
        faq.setAutoUpdateEnabled(faqDto.getAutoUpdateEnabled() != null ? faqDto.getAutoUpdateEnabled() : true);

        // 検索ベクトル生成
        faq.updateSearchVector();

        // タグとキーワードの処理
        if (faqDto.getTagList() != null && !faqDto.getTagList().isEmpty()) {
            faq.setTags(String.join(",", faqDto.getTagList()));
        }
        if (faqDto.getKeywordList() != null && !faqDto.getKeywordList().isEmpty()) {
            faq.setKeywords(String.join(",", faqDto.getKeywordList()));
        }

        LearningAiFaq savedFaq = faqRepository.save(faq);
        log.info("FAQ作成完了: id={}", savedFaq.getId());

        return convertToDto(savedFaq);
    }

    /**
     * FAQ更新
     */
    @Transactional
    public LearningAiFaqDto updateFaq(Long id, LearningAiFaqDto faqDto) {
        log.info("FAQ更新開始: id={}", id);

        LearningAiFaq existingFaq = faqRepository.findByIdAndNotDeleted(id)
                .orElseThrow(() -> new RuntimeException("FAQが見つかりません: " + id));

        // 更新可能フィールドのコピー
        existingFaq.setQuestion(faqDto.getQuestion());
        existingFaq.setAnswer(faqDto.getAnswer());
        existingFaq.setCategory(faqDto.getCategory());
        existingFaq.setSubCategory(faqDto.getSubCategory());
        existingFaq.setPriority(faqDto.getPriority());
        existingFaq.setLanguage(faqDto.getLanguage());
        existingFaq.setAutoUpdateEnabled(faqDto.getAutoUpdateEnabled());

        // タグとキーワードの処理
        if (faqDto.getTagList() != null) {
            existingFaq.setTags(String.join(",", faqDto.getTagList()));
        }
        if (faqDto.getKeywordList() != null) {
            existingFaq.setKeywords(String.join(",", faqDto.getKeywordList()));
        }

        // 検索ベクトル更新
        existingFaq.updateSearchVector();

        LearningAiFaq savedFaq = faqRepository.save(existingFaq);
        log.info("FAQ更新完了: id={}", savedFaq.getId());

        return convertToDto(savedFaq);
    }

    /**
     * FAQ削除（論理削除）
     */
    @Transactional
    public void deleteFaq(Long id) {
        log.info("FAQ削除開始: id={}", id);

        LearningAiFaq faq = faqRepository.findByIdAndNotDeleted(id)
                .orElseThrow(() -> new RuntimeException("FAQが見つかりません: " + id));

        faq.softDelete();
        faqRepository.save(faq);

        log.info("FAQ削除完了: id={}", id);
    }

    /**
     * FAQ取得
     */
    @Transactional(readOnly = true)
    public LearningAiFaqDto getFaqById(Long id) {
        LearningAiFaq faq = faqRepository.findByIdAndNotDeleted(id)
                .orElseThrow(() -> new RuntimeException("FAQが見つかりません: " + id));

        // 閲覧数増加
        faqRepository.incrementViewCount(id);

        return convertToDto(faq);
    }

    /**
     * FAQ取得（閲覧数増加なし）
     */
    @Transactional(readOnly = true)
    public Optional<LearningAiFaqDto> getFaqByIdWithoutIncrement(Long id) {
        return faqRepository.findByIdAndNotDeleted(id)
                .map(this::convertToDto);
    }

    // ========== 検索機能 ==========

    /**
     * 公開FAQ一覧取得
     */
    @Transactional(readOnly = true)
    public Page<LearningAiFaqDto> getPublishedFaqs(Pageable pageable) {
        return faqRepository.findPublishedFaqs(pageable)
                .map(this::convertToDto);
    }

    /**
     * カテゴリー別FAQ取得
     */
    @Transactional(readOnly = true)
    public Page<LearningAiFaqDto> getFaqsByCategory(LearningAiFaq.FaqCategory category, Pageable pageable) {
        return faqRepository.findByCategory(category, pageable)
                .map(this::convertToDto);
    }

    /**
     * ステータス別FAQ取得
     */
    @Transactional(readOnly = true)
    public Page<LearningAiFaqDto> getFaqsByStatus(LearningAiFaq.FaqStatus status, Pageable pageable) {
        return faqRepository.findByStatus(status, pageable)
                .map(this::convertToDto);
    }

    /**
     * 言語別FAQ取得
     */
    @Transactional(readOnly = true)
    public Page<LearningAiFaqDto> getFaqsByLanguage(String language, Pageable pageable) {
        return faqRepository.findByLanguage(language, pageable)
                .map(this::convertToDto);
    }

    /**
     * キーワード検索
     */
    @Transactional(readOnly = true)
    public Page<LearningAiFaqDto> searchFaqs(String keyword, Pageable pageable) {
        return faqRepository.searchByKeyword(keyword, pageable)
                .map(this::convertToDto);
    }

    /**
     * 高度な検索
     */
    @Transactional(readOnly = true)
    public Page<LearningAiFaqDto> advancedSearch(
            LearningAiFaq.FaqCategory category,
            String subCategory,
            String keyword,
            String language,
            LearningAiFaq.FaqStatus status,
            Pageable pageable) {

        return faqRepository.advancedSearch(category, subCategory, keyword, language, status, pageable)
                .map(this::convertToDto);
    }

    /**
     * タグ検索
     */
    @Transactional(readOnly = true)
    public List<LearningAiFaqDto> searchByTag(String tag) {
        return faqRepository.findByTag(tag).stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    /**
     * 関連FAQ取得
     */
    @Transactional(readOnly = true)
    public List<LearningAiFaqDto> getRelatedFaqs(Long faqId, int limit) {
        LearningAiFaq faq = faqRepository.findByIdAndNotDeleted(faqId)
                .orElseThrow(() -> new RuntimeException("FAQが見つかりません: " + faqId));

        return faqRepository.findRelatedFaqs(faq.getCategory(), faqId, PageRequest.of(0, limit))
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    // ========== 人気・品質関連 ==========

    /**
     * 人気FAQ取得
     */
    @Transactional(readOnly = true)
    public List<LearningAiFaqDto> getPopularFaqs(int limit) {
        return faqRepository.findPopularFaqs(PageRequest.of(0, limit))
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    /**
     * 高品質FAQ取得
     */
    @Transactional(readOnly = true)
    public List<LearningAiFaqDto> getHighQualityFaqs(BigDecimal minScore, int limit) {
        return faqRepository.findHighQualityFaqs(minScore, PageRequest.of(0, limit))
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    /**
     * 最新FAQ取得
     */
    @Transactional(readOnly = true)
    public List<LearningAiFaqDto> getRecentFaqs(int limit) {
        return faqRepository.findRecentFaqs(PageRequest.of(0, limit))
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    /**
     * 最も閲覧されたFAQ取得
     */
    @Transactional(readOnly = true)
    public List<LearningAiFaqDto> getMostViewedFaqs(int limit) {
        return faqRepository.findMostViewedFaqs(PageRequest.of(0, limit))
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    // ========== 評価機能 ==========

    /**
     * 役に立った投票
     */
    @Transactional
    public void markAsHelpful(Long faqId) {
        log.info("役に立った投票: faqId={}", faqId);

        LearningAiFaq faq = faqRepository.findByIdAndNotDeleted(faqId)
                .orElseThrow(() -> new RuntimeException("FAQが見つかりません: " + faqId));

        faq.addHelpfulVote();
        faqRepository.save(faq);
    }

    /**
     * 役に立たなかった投票
     */
    @Transactional
    public void markAsNotHelpful(Long faqId) {
        log.info("役に立たなかった投票: faqId={}", faqId);

        LearningAiFaq faq = faqRepository.findByIdAndNotDeleted(faqId)
                .orElseThrow(() -> new RuntimeException("FAQが見つかりません: " + faqId));

        faq.addNotHelpfulVote();
        faqRepository.save(faq);
    }

    /**
     * 評価処理
     */
    @Transactional
    public void rateFaq(Long faqId, boolean isHelpful) {
        if (isHelpful) {
            markAsHelpful(faqId);
        } else {
            markAsNotHelpful(faqId);
        }
    }

    // ========== AI関連機能 ==========

    /**
     * AI生成FAQ取得
     */
    @Transactional(readOnly = true)
    public Page<LearningAiFaqDto> getAiGeneratedFaqs(Pageable pageable) {
        return faqRepository.findAiGeneratedFaqs(pageable)
                .map(this::convertToDto);
    }

    /**
     * 高信頼度AI生成FAQ取得
     */
    @Transactional(readOnly = true)
    public List<LearningAiFaqDto> getHighConfidenceAiFaqs(BigDecimal minConfidence) {
        return faqRepository.findHighConfidenceAiFaqs(minConfidence)
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    /**
     * AI更新対象FAQ取得
     */
    @Transactional(readOnly = true)
    public List<LearningAiFaqDto> getFaqsForAiUpdate() {
        return faqRepository.findFaqsForAiUpdate(LocalDateTime.now())
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    /**
     * AI FAQ生成（モック実装）
     */
    @Transactional
    public LearningAiFaqDto generateAiFaq(LearningAiFaqDto.AiGenerationRequest request) {
        log.info("AI FAQ生成開始: category={}, language={}", request.getCategory(), request.getLanguage());

        // TODO: 実際のAI API連携を実装
        LearningAiFaq aiFaq = new LearningAiFaq();
        aiFaq.setQuestion("AI生成された質問: " + request.getCategory().getDisplayName());
        aiFaq.setAnswer("AI生成された回答です。詳細な説明が含まれます。");
        aiFaq.setCategory(request.getCategory());
        aiFaq.setSubCategory(request.getSubCategory());
        aiFaq.setLanguage(request.getLanguage());
        aiFaq.setPriority(5);
        aiFaq.setStatus(LearningAiFaq.FaqStatus.PENDING_REVIEW);
        aiFaq.setIsAutoGenerated(true);
        aiFaq.setAiConfidence(
                request.getMinConfidence() != null ? request.getMinConfidence() : BigDecimal.valueOf(0.8));
        aiFaq.setAiModel(request.getAiModel() != null ? request.getAiModel() : "gpt-4");
        aiFaq.setAutoUpdateEnabled(true);

        if (request.getKeywords() != null && !request.getKeywords().isEmpty()) {
            aiFaq.setKeywords(String.join(",", request.getKeywords()));
        }

        aiFaq.updateSearchVector();
        aiFaq.scheduleNextAiUpdate(30); // 30日後に再更新

        LearningAiFaq savedFaq = faqRepository.save(aiFaq);
        log.info("AI FAQ生成完了: id={}", savedFaq.getId());

        return convertToDto(savedFaq);
    }

    /**
     * AI更新実行
     */
    @Transactional
    public void executeAiUpdate(Long faqId) {
        log.info("AI更新実行: faqId={}", faqId);

        LearningAiFaq faq = faqRepository.findByIdAndNotDeleted(faqId)
                .orElseThrow(() -> new RuntimeException("FAQが見つかりません: " + faqId));

        // TODO: 実際のAI更新ロジックを実装
        faq.setLastAiUpdateAt(LocalDateTime.now());
        faq.scheduleNextAiUpdate(30); // 30日後に再更新

        faqRepository.save(faq);
        log.info("AI更新完了: faqId={}", faqId);
    }

    // ========== 管理機能 ==========

    /**
     * FAQ承認
     */
    @Transactional
    public void approveFaq(Long faqId, UUID approverId) {
        log.info("FAQ承認: faqId={}, approverId={}", faqId, approverId);

        faqRepository.approveFaq(faqId, approverId);
    }

    /**
     * ステータス更新
     */
    @Transactional
    public void updateStatus(Long faqId, LearningAiFaq.FaqStatus status, UUID updatedBy) {
        log.info("ステータス更新: faqId={}, status={}", faqId, status);

        faqRepository.updateStatus(faqId, status, updatedBy);
    }

    /**
     * FAQ復元
     */
    @Transactional
    public void restoreFaq(Long faqId) {
        log.info("FAQ復元: faqId={}", faqId);

        faqRepository.restore(faqId);
    }

    // ========== 統計・分析 ==========

    /**
     * カテゴリー別FAQ数取得
     */
    @Transactional(readOnly = true)
    public Long countByCategory(LearningAiFaq.FaqCategory category) {
        return faqRepository.countByCategory(category);
    }

    /**
     * ステータス別FAQ数取得
     */
    @Transactional(readOnly = true)
    public Long countByStatus(LearningAiFaq.FaqStatus status) {
        return faqRepository.countByStatus(status);
    }

    /**
     * 期間別統計取得
     */
    @Transactional(readOnly = true)
    public List<Map<String, Object>> getFaqCountByDateRange(LocalDateTime fromDate, LocalDateTime toDate) {
        return faqRepository.getFaqCountByDateRange(fromDate, toDate);
    }

    /**
     * カテゴリー別統計取得
     */
    @Transactional(readOnly = true)
    public List<Map<String, Object>> getCategoryStatistics() {
        return faqRepository.getCategoryStatistics();
    }

    /**
     * 全体統計取得
     */
    @Transactional(readOnly = true)
    public LearningAiFaqDto.FaqStatistics getOverallStatistics() {
        Map<String, Object> stats = faqRepository.getOverallStatistics();

        return LearningAiFaqDto.FaqStatistics.builder()
                .totalFaqs(((Number) stats.get("totalFaqs")).longValue())
                .publishedFaqs(((Number) stats.get("publishedFaqs")).longValue())
                .draftFaqs(((Number) stats.get("draftFaqs")).longValue())
                .autoGeneratedFaqs(((Number) stats.get("aiGeneratedFaqs")).longValue())
                .needsUpdateFaqs(((Number) stats.get("needsUpdateFaqs")).longValue())
                .averageUsefulnessScore((BigDecimal) stats.get("avgUsefulnessScore"))
                .averagePopularityScore((BigDecimal) stats.get("avgPopularityScore"))
                .totalViews(((Number) stats.get("totalViews")).longValue())
                .totalHelpfulVotes(((Number) stats.get("totalHelpfulVotes")).longValue())
                .totalNotHelpfulVotes(((Number) stats.get("totalNotHelpfulVotes")).longValue())
                .lastUpdated(LocalDateTime.now())
                .build();
    }

    // ========== バッチ処理 ==========

    /**
     * 古いFAQのアーカイブ
     */
    @Transactional
    public void archiveOldFaqs(LocalDateTime cutoffDate, Long minViewCount) {
        log.info("古いFAQアーカイブ開始: cutoffDate={}, minViewCount={}", cutoffDate, minViewCount);

        int archivedCount = faqRepository.archiveOldFaqs(cutoffDate, minViewCount);
        log.info("古いFAQアーカイブ完了: archivedCount={}", archivedCount);
    }

    /**
     * 低品質FAQのマーク
     */
    @Transactional
    public void markLowQualityFaqs(BigDecimal minScore) {
        log.info("低品質FAQマーク開始: minScore={}", minScore);

        int markedCount = faqRepository.markLowQualityFaqs(minScore);
        log.info("低品質FAQマーク完了: markedCount={}", markedCount);
    }

    /**
     * スコア再計算
     */
    @Transactional
    public void recalculateScores() {
        log.info("スコア再計算開始");

        faqRepository.recalculatePopularityScores();
        faqRepository.recalculateUsefulnessScores();

        log.info("スコア再計算完了");
    }

    /**
     * 検索ベクトル一括更新
     */
    @Transactional
    public void updateAllSearchVectors() {
        log.info("検索ベクトル一括更新開始");

        int updatedCount = faqRepository.updateAllSearchVectors();
        log.info("検索ベクトル一括更新完了: updatedCount={}", updatedCount);
    }

    // ========== ヘルパーメソッド ==========

    /**
     * EntityからDTOへの変換
     */
    private LearningAiFaqDto convertToDto(LearningAiFaq entity) {
        LearningAiFaqDto dto = new LearningAiFaqDto();
        BeanUtils.copyProperties(entity, dto);

        // 追加フィールドの設定
        dto.setCategoryDisplayName(entity.getCategory().getDisplayName());
        dto.setStatusDisplayName(entity.getStatus().getDisplayName());

        // タグ配列の設定
        if (entity.getTags() != null && !entity.getTags().isEmpty()) {
            dto.setTagList(Arrays.asList(entity.getTags().split(",")));
        }

        // キーワード配列の設定
        if (entity.getKeywords() != null && !entity.getKeywords().isEmpty()) {
            dto.setKeywordList(Arrays.asList(entity.getKeywords().split(",")));
        }

        // 関連FAQ ID配列の設定
        if (entity.getRelatedFaqIds() != null && !entity.getRelatedFaqIds().isEmpty()) {
            dto.setRelatedFaqIdList(Arrays.stream(entity.getRelatedFaqIds().split(","))
                    .map(Long::valueOf)
                    .collect(Collectors.toList()));
        }

        // 計算値の設定
        dto.setTotalVotes(entity.getHelpfulCount() + entity.getNotHelpfulCount());
        if (dto.getTotalVotes() > 0) {
            dto.setHelpfulRatio((double) entity.getHelpfulCount() / dto.getTotalVotes());
        } else {
            dto.setHelpfulRatio(0.0);
        }

        // フラグの設定
        dto.setIsPublished(entity.isPublished());
        dto.setIsDeleted(entity.isDeleted());
        dto.setIsAiGenerated(entity.isAiGenerated());
        dto.setNeedsUpdate(entity.getStatus() == LearningAiFaq.FaqStatus.NEEDS_UPDATE);
        dto.setIsPendingApproval(entity.getStatus() == LearningAiFaq.FaqStatus.PENDING_REVIEW);
        dto.setIsAutoUpdateTarget(entity.getAutoUpdateEnabled() &&
                entity.getNextAiUpdateAt() != null &&
                entity.getNextAiUpdateAt().isBefore(LocalDateTime.now().plusDays(7)));

        return dto;
    }

    /**
     * DTOからEntityへの変換（必要時使用）
     */
    @SuppressWarnings("unused")
    private LearningAiFaq convertToEntity(LearningAiFaqDto dto) {
        LearningAiFaq entity = new LearningAiFaq();
        BeanUtils.copyProperties(dto, entity, "id", "createdAt", "updatedAt");

        // タグとキーワードの変換
        if (dto.getTagList() != null && !dto.getTagList().isEmpty()) {
            entity.setTags(String.join(",", dto.getTagList()));
        }
        if (dto.getKeywordList() != null && !dto.getKeywordList().isEmpty()) {
            entity.setKeywords(String.join(",", dto.getKeywordList()));
        }
        if (dto.getRelatedFaqIdList() != null && !dto.getRelatedFaqIdList().isEmpty()) {
            entity.setRelatedFaqIds(dto.getRelatedFaqIdList().stream()
                    .map(String::valueOf)
                    .collect(Collectors.joining(",")));
        }

        return entity;
    }
}
